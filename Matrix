#!/usr/bin/env python3

import random
import time
import os
import sys
import signal
import select
import tty
import termios

class MatrixRainCMatrix:
    def __init__(self):
        self.width = 0
        self.height = 0
        self.running = False
        self.speed = 0.08
        self.current_palette = 'matrix'
        self.update_terminal_size()

        self.palettes = {
            'matrix': [
                '\033[38;5;46m', '\033[38;5;82m', '\033[38;5;118m',
                '\033[38;5;154m', '\033[38;5;190m', '\033[38;5;226m',
                '\033[1;38;5;46m', '\033[1;38;5;82m', '\033[1;38;5;118m'
            ],
            'fire': [
                '\033[38;5;196m', '\033[38;5;202m', '\033[38;5;208m',
                '\033[38;5;214m', '\033[38;5;220m', '\033[38;5;226m',
                '\033[1;38;5;196m', '\033[1;38;5;202m', '\033[1;38;5;208m'
            ],
            'ice': [
                '\033[38;5;39m', '\033[38;5;45m', '\033[38;5;51m',
                '\033[38;5;87m', '\033[38;5;123m', '\033[38;5;159m',
                '\033[1;38;5;39m', '\033[1;38;5;45m', '\033[1;38;5;51m'
            ],
            'cyber': [
                '\033[38;5;93m', '\033[38;5;129m', '\033[38;5;165m',
                '\033[38;5;201m', '\033[38;5;213m', '\033[38;5;219m',
                '\033[1;38;5;93m', '\033[1;38;5;129m', '\033[1;38;5;165m'
            ],
            'gold': [
                '\033[38;5;220m', '\033[38;5;214m', '\033[38;5;208m',
                '\033[38;5;202m', '\033[38;5;196m', '\033[38;5;226m',
                '\033[1;38;5;220m', '\033[1;38;5;214m', '\033[1;38;5;208m'
            ],
            'ocean': [
                '\033[38;5;27m', '\033[38;5;39m', '\033[38;5;45m',
                '\033[38;5;51m', '\033[38;5;87m', '\033[38;5;123m',
                '\033[1;38;5;27m', '\033[1;38;5;39m', '\033[1;38;5;45m'
            ]
        }

        self.colors = self.palettes['matrix']

        self.reset_color = '\033[0m'

        self.characters = {
            'classic': ['0', '1'],
            'hex': ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'],
            'binary': ['0', '1'],
            'katakana': ['„Ç¢', '„Ç§', '„Ç¶', '„Ç®', '„Ç™', '„Ç´', '„Ç≠', '„ÇØ', '„Ç±', '„Ç≥', '„Çµ', '„Ç∑', '„Çπ', '„Çª', '„ÇΩ'],
            'extended': ['‚ñë', '‚ñí', '‚ñì', '‚ñà', '‚ñÑ', '‚ñÄ', '‚ñå', '‚ñê', '‚ñ¨', '‚ñ≤', '‚ñ∫', '‚ñº', '‚óÑ', '‚óè', '‚óã', '‚óé', '‚óá', '‚óÜ'],
            'matrix': ['Œ¶', 'Œò', 'Œõ', 'Œû', 'Œ†', 'Œ£', 'Œ®', 'Œ©', 'Œ±', 'Œ≤', 'Œ≥', 'Œ¥', 'Œµ', 'Œ∂', 'Œ∑', 'Œ∏'],
            'fire': ['$', '#', '%', '@', '&', '*', '+', '=', '~', '|'],
            'ice': ['‚ùÑ', '‚õÑ', '‚ô¶', 'üíé', 'üî∑', 'üîπ', 'üí†', 'üî∂', 'üî∏'],
            'cyber': ['‚üÅ', '‚è£', '‚å¨', '‚çü', '‚èö', '‚çé', '‚åá', '‚èÉ'],
            'waves': ['~', '‚âà', '‚àΩ', '‚âã', '„Ä∞', 'ÔΩû'],
            'rings': ['‚óã', '‚óé', '‚óè', '‚óâ', '‚óå', '„Äá'],
            'spiral': ['‚Üª', '‚Ü∫', '‚ü≤', '‚ü≥', '‚§∏', '‚§π']
        }

        self.drops = []
        self.old_settings = None

    def update_terminal_size(self):
        try:
            cols, rows = os.get_terminal_size()
            self.width = cols
            self.height = rows
        except:
            self.width = 80
            self.height = 24

    def clear_screen(self):
        os.system('clear' if os.name != 'nt' else 'cls')

    def hide_cursor(self):
        sys.stdout.write('\033[?25l')
        sys.stdout.flush()

    def show_cursor(self):
        sys.stdout.write('\033[?25h')
        sys.stdout.flush()

    def setup_keyboard(self):
        self.old_settings = termios.tcgetattr(sys.stdin)
        tty.setraw(sys.stdin.fileno())

    def restore_keyboard(self):
        if self.old_settings:
            termios.tcsetattr(sys.stdin, termios.TCSADRAIN, self.old_settings)

    def check_key(self):
        dr, dw, de = select.select([sys.stdin], [], [], 0.01)
        if dr:
            return sys.stdin.read(1)
        return None

    def init_drops_cmatrix(self, mode='classic'):
        self.drops = []
        chars = self.characters[mode]

        color_palette = self.palettes[self.current_palette]

        for x in range(self.width):
            if random.random() < 0.3:
                length = random.randint(5, 25)
                speed = random.uniform(0.05, 0.15)
                start_pos = -length

                if self.current_palette == 'fire':
                    head_color = '\033[1;38;5;196m'
                    tail_color = '\033[38;5;88m'
                elif self.current_palette == 'ice':
                    head_color = '\033[1;38;5;39m'
                    tail_color = '\033[38;5;23m'
                elif self.current_palette == 'cyber':
                    head_color = '\033[1;38;5;93m'
                    tail_color = '\033[38;5;55m'
                elif self.current_palette == 'gold':
                    head_color = '\033[1;38;5;220m'
                    tail_color = '\033[38;5;94m'
                elif self.current_palette == 'ocean':
                    head_color = '\033[1;38;5;39m'
                    tail_color = '\033[38;5;24m'
                else:
                    head_color = random.choice(['\033[1;38;5;46m', '\033[1;38;5;82m', '\033[1;38;5;118m'])
                    tail_color = random.choice(['\033[38;5;22m', '\033[38;5;28m', '\033[38;5;34m'])

                self.drops.append({
                    'x': x,
                    'y': start_pos,
                    'length': length,
                    'speed': speed,
                    'chars': [random.choice(chars) for _ in range(length)],
                    'head_color': head_color,
                    'body_color': random.choice(color_palette),
                    'tail_color': tail_color,
                    'active': True,
                    'delay': random.randint(0, 50)
                })

    def draw_cmatrix_rain(self, mode='classic'):
        self.running = True
        self.update_terminal_size()
        self.clear_screen()
        self.hide_cursor()
        self.setup_keyboard()
        self.init_drops_cmatrix(mode)

        last_update = time.time()

        sys.stderr = open(os.devnull, 'w')

        try:
            while self.running:
                key = self.check_key()
                if key:
                    if key == 'q':
                        break
                    elif key in '0123456789':
                        speed_map = {
                            '0': 0.15, '1': 0.12, '2': 0.10, '3': 0.08,
                            '4': 0.06, '5': 0.05, '6': 0.04, '7': 0.03,
                            '8': 0.02, '9': 0.01
                        }
                        self.speed = speed_map[key]
                    elif key.lower() == 'g':
                        self.current_palette = 'matrix'
                    elif key.lower() == 'r':
                        self.current_palette = 'fire'
                    elif key.lower() == 'b':
                        self.current_palette = 'ice'
                    elif key.lower() == 'p':
                        self.current_palette = 'cyber'
                    elif key.lower() == 'y':
                        self.current_palette = 'gold'
                    elif key.lower() == 'o':
                        self.current_palette = 'ocean'
                    elif key == '\x03':
                        break

                current_time = time.time()

                if current_time - last_update < 0.03:
                    time.sleep(0.001)
                    continue

                last_update = current_time

                buffer = ['\033[H']

                for drop in self.drops[:]:
                    if drop['delay'] > 0:
                        drop['delay'] -= 1
                        continue

                    drop['y'] += drop['speed'] * (self.speed / 0.08)

                    if drop['y'] > self.height + drop['length']:
                        if random.random() < 0.02:
                            drop['y'] = -drop['length']
                            drop['delay'] = random.randint(0, 20)
                        else:
                            self.drops.remove(drop)
                            continue

                    for i in range(drop['length']):
                        screen_y = int(drop['y']) - i

                        if 0 <= screen_y < self.height:
                            char_idx = i % len(drop['chars'])
                            char = drop['chars'][char_idx]

                            if i == 0:
                                color = drop['head_color']
                            elif i < 3:
                                color = drop['head_color']
                            elif i < 6:
                                color = drop['body_color']
                            else:
                                color = drop['tail_color']
                                if random.random() < 0.3:
                                    char = ' '

                            buffer.append(f"\033[{screen_y + 1};{drop['x'] + 1}H{color}{char}")

                if random.random() < 0.3:
                    chars = self.characters[mode]
                    new_x = random.randint(0, self.width - 1)
                    if not any(abs(d['x'] - new_x) < 2 for d in self.drops if d['delay'] <= 0):
                        length = random.randint(8, 20)

                        if self.current_palette == 'fire':
                            head_color = '\033[1;38;5;196m'
                            tail_color = '\033[38;5;88m'
                        elif self.current_palette == 'ice':
                            head_color = '\033[1;38;5;39m'
                            tail_color = '\033[38;5;23m'
                        elif self.current_palette == 'cyber':
                            head_color = '\033[1;38;5;93m'
                            tail_color = '\033[38;5;55m'
                        elif self.current_palette == 'gold':
                            head_color = '\033[1;38;5;220m'
                            tail_color = '\033[38;5;94m'
                        elif self.current_palette == 'ocean':
                            head_color = '\033[1;38;5;39m'
                            tail_color = '\033[38;5;24m'
                        else:
                            head_color = random.choice(['\033[1;38;5;46m', '\033[1;38;5;82m'])
                            tail_color = random.choice(['\033[38;5;22m', '\033[38;5;28m'])

                        self.drops.append({
                            'x': new_x,
                            'y': -length,
                            'length': length,
                            'speed': random.uniform(0.08, 0.18),
                            'chars': [random.choice(chars) for _ in range(length)],
                            'head_color': head_color,
                            'body_color': random.choice(self.palettes[self.current_palette]),
                            'tail_color': tail_color,
                            'active': True,
                            'delay': 0
                        })

                sys.stdout.write(''.join(buffer))
                sys.stdout.flush()

        except KeyboardInterrupt:
            pass
        except Exception:
            pass
        finally:
            sys.stderr = sys.__stderr__
            self.restore_keyboard()
            self.show_cursor()
            self.running = False

    def print_logo(self):
        logo_lines = [
            "\033[1;38;5;196m‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó",
            "\033[1;38;5;208m ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó",
            "\033[1;38;5;214m ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë",
            "\033[1;38;5;220m ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù  ‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë",
            "\033[1;38;5;226m ‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù",
            "\033[1;38;5;196m‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù"
        ]

        for line in logo_lines:
            print(line.center(self.width))

        print()
        print("\033[38;5;82m Creator Channel: t.me/Red_Rooted_ghost ".center(self.width))
        print()

    def show_help(self):
        self.clear_screen()
        help_text = """
\033[1;96m‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
\033[1;95m‚ïë                  MATRIX RAIN - HELP MENU                 ‚ïë
\033[1;96m‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

\033[1;92mAvailable Effects:\033[0m

\033[1;93m[1]\033[0m Classic CMatrix - Green binary rain
\033[1;93m[2]\033[0m Hex Storm - Hexadecimal characters
\033[1;93m[3]\033[0m Katakana Flow - Japanese characters
\033[1;93m[4]\033[0m Greek Matrix - Greek symbols
\033[1;93m[5]\033[0m ASCII Art - Extended ASCII characters
\033[1;93m[6]\033[0m Fire Storm - Red/orange fire effect
\033[1;93m[7]\033[0m Ice Crystal - Blue/white ice effect
\033[1;93m[8]\033[0m Cyber Punk - Purple cyber symbols
\033[1;93m[9]\033[0m Wave Flow - Wave pattern characters
\033[1;93m[10]\033[0m Ring Effect - Circular characters
\033[1;93m[11]\033[0m Spiral Motion - Spinning characters

\033[1;92mReal-Time Controls (During Rain):\033[0m

\033[1;94mSpeed Control:\033[0m
\033[93m0-9\033[0m: Change speed (0=fastest, 9=slowest)

\033[1;94mColor Control:\033[0m
\033[93mG\033[0m: Green Matrix    \033[93mR\033[0m: Red Fire
\033[93mB\033[0m: Blue Ice        \033[93mP\033[0m: Purple Cyber
\033[93mY\033[0m: Yellow Gold     \033[93mO\033[0m: Ocean Blue

\033[1;94mOther Controls:\033[0m
\033[93mQ\033[0m: Quit to menu
\033[93mCtrl+C\033[0m: Exit directly

\033[1;92mNavigation:\033[0m
‚Ä¢ Select numbers 1-11 for different effects
‚Ä¢ Press \033[1;93m12\033[0m for help
‚Ä¢ Press \033[1;93m0\033[0m to exit program

\033[1;95mPress Enter to return to main menu...\033[0m
        """
        print(help_text)
        input()

    def run_menu(self):
        signal.signal(signal.SIGWINCH, lambda sig, frame: self.update_terminal_size())

        while True:
            self.clear_screen()
            self.print_logo()

            print(f"\n\033[1;38;5;82m{'‚ïê' * min(64, self.width - 4)}\033[0m")
            print(f"\033[1;38;5;46m[1]\033[0m \033[38;5;118mClassic CMatrix Binary Rain\033[0m")
            print(f"\033[1;38;5;46m[2]\033[0m \033[38;5;118mHex Code Digital Storm\033[0m")
            print(f"\033[1;38;5;46m[3]\033[0m \033[38;5;118mKatakana Character Rain\033[0m")
            print(f"\033[1;38;5;46m[4]\033[0m \033[38;5;118mMatrix Greek Symbols\033[0m")
            print(f"\033[1;38;5;46m[5]\033[0m \033[38;5;118mExtended ASCII Flow\033[0m")
            print(f"\033[1;38;5;196m[6]\033[0m \033[38;5;196mFire Storm Effect\033[0m")
            print(f"\033[1;38;5;39m[7]\033[0m \033[38;5;39mIce Crystal Rain\033[0m")
            print(f"\033[1;38;5;93m[8]\033[0m \033[38;5;93mCyber Punk Effect\033[0m")
            print(f"\033[1;38;5;45m[9]\033[0m \033[38;5;45mWave Flow Pattern\033[0m")
            print(f"\033[1;38;5;51m[10]\033[0m \033[38;5;51mRing Circular Flow\033[0m")
            print(f"\033[1;38;5;87m[11]\033[0m \033[38;5;87mSpiral Motion Effect\033[0m")
            print(f"\033[1;38;5;226m[12]\033[0m \033[38;5;226mHelp & Information\033[0m")
            print(f"\033[1;38;5;196m[0]\033[0m \033[38;5;196mExit Program\033[0m")
            print(f"\033[1;38;5;82m{'‚ïê' * min(64, self.width - 4)}\033[0m")

            try:
                choice = input(f"\n\033[1;38;5;46mSelect mode ‚ñ∫ \033[0m")

                modes = {
                    '1': 'classic',
                    '2': 'hex',
                    '3': 'katakana',
                    '4': 'matrix',
                    '5': 'extended',
                    '6': 'fire',
                    '7': 'ice',
                    '8': 'cyber',
                    '9': 'waves',
                    '10': 'rings',
                    '11': 'spiral'
                }

                if choice == '12':
                    self.show_help()
                elif choice == '0':
                    self.clear_screen()
                    print(f"\n\033[1;38;5;46mTerminating matrix rain...\033[0m\n")
                    sys.exit(0)
                elif choice in modes:
                    self.draw_cmatrix_rain(modes[choice])
                    input(f"\n\033[1;90mPress Enter to return to menu...\033[0m")
                else:
                    print(f"\033[1;38;5;196mInvalid option!\033[0m")
                    time.sleep(1)

            except KeyboardInterrupt:
                print(f"\n\033[1;38;5;226mExiting...\033[0m")
                time.sleep(1)
                sys.exit(0)

def main():
    try:
        os.system('clear')
        cmatrix = MatrixRainCMatrix()
        cmatrix.run_menu()
    except Exception as e:
        print(f"Error: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()
